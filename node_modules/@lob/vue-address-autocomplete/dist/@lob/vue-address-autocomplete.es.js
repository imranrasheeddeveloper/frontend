var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { defineComponent, openBlock, createElementBlock, normalizeClass, toDisplayString, createCommentVNode, withDirectives, createElementVNode, withKeys, withModifiers, vModelText, renderSlot, Fragment, renderList, resolveComponent, createVNode, mergeProps, withCtx, pushScopeId, popScopeId } from "vue";
var TypeAhead_vue_vue_type_style_index_0_lang = "";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$1 = defineComponent({
  name: "TypeAhead",
  emits: ["onInput", "onFocus", "onBlur", "onSelect", "update:modelValue"],
  props: {
    id: {
      type: String
    },
    placeholder: {
      type: String,
      default: ""
    },
    items: {
      type: Array,
      required: true
    },
    defaultItem: {
      default: null
    },
    itemProjection: {
      type: Function,
      default(item) {
        return {
          suggestion: item,
          input: item
        };
      }
    },
    minInputLength: {
      type: Number,
      default: 2,
      validator: (prop) => {
        return prop >= 0;
      }
    },
    label: {
      type: String,
      default: null
    },
    modelValue: {
      type: String,
      default: ""
    },
    isLabelFloating: {
      type: Boolean,
      default: false
    }
  },
  mounted() {
    if (this.defaultItem !== void 0 && this.defaultItem !== null) {
      this.selectItem(this.defaultItem);
    }
  },
  data() {
    return {
      inputId: this.id || `simple_typeahead_${(Math.random() * 1e3).toFixed()}`,
      isInputFocused: false,
      currentSelectionIndex: 0
    };
  },
  methods: {
    onInput(e) {
      if (this.isListVisible && this.currentSelectionIndex >= this.filteredItems.length) {
        this.currentSelectionIndex = (this.filteredItems.length || 1) - 1;
      }
      this.$emit("onInput", { input: this.modelValue, items: this.filteredItems });
      this.$emit("update:modelValue", e.target.value);
    },
    onFocus() {
      this.isInputFocused = true;
      this.$emit("onFocus", { input: this.modelValue, items: this.filteredItems });
    },
    onBlur() {
      this.isInputFocused = false;
      this.$emit("onBlur", { input: this.modelValue, items: this.filteredItems });
    },
    onArrowDown($event) {
      if (this.isListVisible && this.currentSelectionIndex < this.filteredItems.length - 1) {
        this.currentSelectionIndex++;
      }
      this.scrollSelectionIntoView();
    },
    onArrowUp($event) {
      if (this.isListVisible && this.currentSelectionIndex > 0) {
        this.currentSelectionIndex--;
      }
      this.scrollSelectionIntoView();
    },
    scrollSelectionIntoView() {
      setTimeout(() => {
        const list_node = document.querySelector(`#${this.wrapperId} .lob-typeahead-list`);
        const active_node = document.querySelector(`#${this.wrapperId} .lob-typeahead-list-item.lob-typeahead-list-item-active`);
        if (!active_node) {
          return;
        }
        if (!(active_node.offsetTop >= list_node.scrollTop && active_node.offsetTop + active_node.offsetHeight < list_node.scrollTop + list_node.offsetHeight)) {
          let scroll_to = 0;
          if (active_node.offsetTop > list_node.scrollTop) {
            scroll_to = active_node.offsetTop + active_node.offsetHeight - list_node.offsetHeight;
          } else if (active_node.offsetTop < list_node.scrollTop) {
            scroll_to = active_node.offsetTop;
          }
          list_node.scrollTo(0, scroll_to);
        }
      });
    },
    selectCurrentSelection() {
      if (this.currentSelection) {
        this.selectItem(this.currentSelection);
      }
    },
    selectItem(item) {
      var _a;
      this.$emit("update:modelValue", this.itemProjection(item).input);
      this.$emit("onSelect", item);
      this.currentSelectionIndex = 0;
      (_a = document.getElementById(this.inputId)) == null ? void 0 : _a.blur();
      this.isInputFocused = false;
    },
    escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    },
    boldMatchText(text) {
      const regexp = new RegExp(`(${this.escapeRegExp(this.modelValue)})`, "ig");
      return text.replace(regexp, "<strong>$1</strong>");
    }
  },
  computed: {
    wrapperId() {
      return `${this.inputId}_wrapper`;
    },
    filteredItems() {
      return this.items || [];
    },
    isListVisible() {
      const isInputValid = this.modelValue.length >= this.minInputLength;
      return this.isInputFocused && isInputValid && this.filteredItems.length;
    },
    currentSelection() {
      return this.isListVisible && this.currentSelectionIndex < this.filteredItems.length ? this.filteredItems[this.currentSelectionIndex] : void 0;
    },
    inputValue: {
      get() {
        return this.modelValue;
      },
      set(newValue) {
        this.$emit("update:modelValue", newValue);
      }
    }
  }
});
const _hoisted_1$1 = ["id"];
const _hoisted_2$1 = ["for"];
const _hoisted_3$1 = ["id", "placeholder"];
const _hoisted_4$1 = {
  key: 1,
  class: "lob-typeahead-list"
};
const _hoisted_5$1 = { key: 0 };
const _hoisted_6$1 = ["onClick", "onMouseenter"];
const _hoisted_7$1 = ["data-text"];
const _hoisted_8 = ["data-text", "innerHTML"];
const _hoisted_9 = { key: 1 };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    id: _ctx.wrapperId,
    class: "lob-typeahead-root"
  }, [
    _ctx.label ? (openBlock(), createElementBlock("label", {
      key: 0,
      for: _ctx.inputId,
      class: normalizeClass(["lob-typeahead-label", !_ctx.isLabelFloating ? "lob-typeahead-label-absolute" : "lob-typeahead-label-floating"])
    }, toDisplayString(_ctx.label), 11, _hoisted_2$1)) : createCommentVNode("", true),
    withDirectives(createElementVNode("input", {
      id: _ctx.inputId,
      class: normalizeClass(["lob-typeahead-input", _ctx.label && !_ctx.isLabelFloating && "lob-typeahead-input-with-label"]),
      type: "text",
      placeholder: _ctx.placeholder,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
      onInput: _cache[1] || (_cache[1] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
      onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
      onKeydown: [
        _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => _ctx.onArrowDown && _ctx.onArrowDown(...args), ["prevent"]), ["down"])),
        _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.onArrowUp && _ctx.onArrowUp(...args), ["prevent"]), ["up"])),
        _cache[6] || (_cache[6] = withKeys((...args) => _ctx.selectCurrentSelection && _ctx.selectCurrentSelection(...args), ["enter", "tab"]))
      ],
      autocomplete: "off"
    }, null, 42, _hoisted_3$1), [
      [vModelText, _ctx.inputValue]
    ]),
    _ctx.isListVisible ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
      _ctx.$slots["list-header"] ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
        renderSlot(_ctx.$slots, "list-header")
      ])) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filteredItems, (item, index) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["lob-typeahead-list-item", { "lob-typeahead-list-item-active": _ctx.currentSelectionIndex == index }]),
          key: index,
          onMousedown: _cache[7] || (_cache[7] = withModifiers(() => {
          }, ["prevent"])),
          onClick: ($event) => _ctx.selectItem(item),
          onMouseenter: ($event) => _ctx.currentSelectionIndex = index
        }, [
          _ctx.$slots["list-item-text"] ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: "lob-typeahead-list-item-text",
            "data-text": _ctx.itemProjection(item).suggestion
          }, [
            renderSlot(_ctx.$slots, "list-item-text", {
              item,
              itemProjection: _ctx.itemProjection
            })
          ], 8, _hoisted_7$1)) : (openBlock(), createElementBlock("span", {
            key: 1,
            class: "lob-typeahead-list-item-text",
            "data-text": _ctx.itemProjection(item).input,
            innerHTML: _ctx.itemProjection(item).suggestion
          }, null, 8, _hoisted_8))
        ], 42, _hoisted_6$1);
      }), 128)),
      _ctx.$slots["list-footer"] ? (openBlock(), createElementBlock("div", _hoisted_9, [
        renderSlot(_ctx.$slots, "list-footer")
      ])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true)
  ], 8, _hoisted_1$1);
}
var TypeAhead = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var base64$1 = { exports: {} };
/*! https://mths.be/base64 v1.0.0 by @mathias | MIT license */
(function(module, exports) {
  (function(root) {
    var freeExports = exports;
    var freeModule = module && module.exports == freeExports && module;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
      root = freeGlobal;
    }
    var InvalidCharacterError = function(message) {
      this.message = message;
    };
    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = "InvalidCharacterError";
    var error = function(message) {
      throw new InvalidCharacterError(message);
    };
    var TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;
    var decode = function(input) {
      input = String(input).replace(REGEX_SPACE_CHARACTERS, "");
      var length = input.length;
      if (length % 4 == 0) {
        input = input.replace(/==?$/, "");
        length = input.length;
      }
      if (length % 4 == 1 || /[^+a-zA-Z0-9/]/.test(input)) {
        error("Invalid character: the string to be decoded is not correctly encoded.");
      }
      var bitCounter = 0;
      var bitStorage;
      var buffer;
      var output = "";
      var position = -1;
      while (++position < length) {
        buffer = TABLE.indexOf(input.charAt(position));
        bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
        if (bitCounter++ % 4) {
          output += String.fromCharCode(255 & bitStorage >> (-2 * bitCounter & 6));
        }
      }
      return output;
    };
    var encode = function(input) {
      input = String(input);
      if (/[^\0-\xFF]/.test(input)) {
        error("The string to be encoded contains characters outside of the Latin1 range.");
      }
      var padding = input.length % 3;
      var output = "";
      var position = -1;
      var a;
      var b;
      var c;
      var buffer;
      var length = input.length - padding;
      while (++position < length) {
        a = input.charCodeAt(position) << 16;
        b = input.charCodeAt(++position) << 8;
        c = input.charCodeAt(++position);
        buffer = a + b + c;
        output += TABLE.charAt(buffer >> 18 & 63) + TABLE.charAt(buffer >> 12 & 63) + TABLE.charAt(buffer >> 6 & 63) + TABLE.charAt(buffer & 63);
      }
      if (padding == 2) {
        a = input.charCodeAt(position) << 8;
        b = input.charCodeAt(++position);
        buffer = a + b;
        output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 63) + TABLE.charAt(buffer << 2 & 63) + "=";
      } else if (padding == 1) {
        buffer = input.charCodeAt(position);
        output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 63) + "==";
      }
      return output;
    };
    var base642 = {
      "encode": encode,
      "decode": decode,
      "version": "1.0.0"
    };
    if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        freeModule.exports = base642;
      } else {
        for (var key in base642) {
          base642.hasOwnProperty(key) && (freeExports[key] = base642[key]);
        }
      }
    } else {
      root.base64 = base642;
    }
  })(commonjsGlobal);
})(base64$1, base64$1.exports);
var base64 = base64$1.exports;
const postAutocompleteAddress = (apiKey, addressPrefix, isStaging = false, additionalAddressData) => {
  const domain = isStaging ? "lob-staging" : "lob";
  const url = `https://api.${domain}.com/v1/us_autocompletions?valid_addresses=true&case=proper`;
  const init = {
    method: "POST",
    headers: {
      Authorization: `Basic ${base64.encode(apiKey + ":")}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(__spreadValues({
      address_prefix: addressPrefix
    }, additionalAddressData))
  };
  return fetch(url, init);
};
const postAutocompleteInternationalAddress = (apiKey, addressPrefix, country, isStaging = false, additionalAddressData) => {
  const domain = isStaging ? "lob-staging" : "lob";
  const url = `https://api.${domain}.com/v1/intl_autocompletions`;
  const init = {
    method: "POST",
    headers: {
      Authorization: `Basic ${base64.encode(apiKey + ":")}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(__spreadValues({
      address_prefix: addressPrefix,
      country
    }, additionalAddressData))
  };
  return fetch(url, init);
};
const postVerifyAddress = (apiKey, address, isStaging = false) => {
  const payload = typeof address === "string" ? { address } : address;
  const domain = isStaging ? "lob-staging" : "lob";
  const url = `https://api.${domain}.com/v1/us_verifications`;
  const init = {
    method: "POST",
    headers: {
      Authorization: `Basic ${base64.encode(apiKey + ":")}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(payload)
  };
  return fetch(url, init);
};
const postVerifyInternationalAddress = (apiKey, address, countryCode, isStaging = false) => {
  const domain = isStaging ? "lob-staging" : "lob";
  const url = `https://api.${domain}.com/v1/intl_verifications`;
  const init = {
    method: "POST",
    headers: {
      Authorization: `Basic ${base64.encode(apiKey + ":")}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ address, country: countryCode })
  };
  return fetch(url, init);
};
var AddressAutocomplete_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main = {
  emits: ["onSuggestions", "onError", "onInput"],
  components: {
    TypeAhead
  },
  props: {
    address: {
      type: Object,
      default: {}
    },
    apiKey: {
      type: String
    },
    country: {
      type: String,
      default: "US"
    },
    isInternational: {
      type: Boolean,
      default: false
    },
    isStaging: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: "Search for an address"
    },
    minInputLength: {
      type: Number,
      default: 1
    },
    primaryLineOnly: {
      type: Boolean,
      default: false
    }
  },
  mounted() {
    if (this.$attrs.onSelectItem) {
      console.error("[@lob/vue-address-autocomplete] Event 'selectItem' has been removed for AddressAutocomplete, please use 'onSelect' instead");
    }
    if (this.$attrs.onNewSuggestions) {
      console.error("[@lob/vue-address-autocomplete] Event 'newSuggestions' has been removed for AddressAutocomplete, please use 'onSuggestions' instead");
    }
  },
  data() {
    return {
      addresses: [],
      input: ""
    };
  },
  methods: {
    formatSuggestions(item) {
      const { primary_line, city, state, zip_code } = item.value;
      let boldStopIndex = 0;
      this.input.split("").forEach((inputChar) => {
        if (inputChar.toLowerCase() === primary_line.charAt(boldStopIndex).toLowerCase()) {
          boldStopIndex += 1;
        }
      });
      const primaryLineElement = boldStopIndex === 0 ? `${primary_line},` : boldStopIndex === primary_line.length ? `<strong>${primary_line},</strong>` : `<span>
            <strong>${primary_line.substring(0, boldStopIndex)}</strong>${primary_line.substring(boldStopIndex)},
          </span>`;
      return {
        input: this.primaryLineOnly ? primary_line : `${primary_line}, ${city}, ${state.toUpperCase()}, ${zip_code}`,
        suggestion: `
          <span>
            ${primaryLineElement}
            <span style="color: #888;">
              ${city},&nbsp;${state.toUpperCase()},&nbsp;${zip_code}
            </span>
          </span>
        `
      };
    },
    handleClickHeader() {
      window.location.href = "https://www.lob.com/address-verification?utm_source=autocomplete&utm_medium=vue";
    },
    async onInput(event) {
      this.selection = null;
      this.input = event.input;
      this.$emit("onInput", this.input);
      const newSuggestions = await this.fetchFromAutocompleteAPI(event.input);
      this.addresses = newSuggestions;
      this.$emit("onSuggestions", newSuggestions);
      this.$forceUpdate();
    },
    async fetchFromAutocompleteAPI(userInput) {
      if (!userInput && true) {
        return [];
      }
      if (this.isInternational && userInput.length < 3) {
        return [];
      }
      if ("primary_line" in this.address) {
        delete this.address.primary_line;
      }
      if ("secondary_line" in this.address) {
        delete this.address.secondary_line;
      }
      const newAddresses = this.isInternational ? await postAutocompleteInternationalAddress(this.apiKey, userInput, this.country, this.isStaging) : await postAutocompleteAddress(this.apiKey, userInput, this.isStaging, this.address);
      const newAddressJSON = await newAddresses.json();
      if (newAddressJSON.error) {
        this.$emit("onError", newAddressJSON.error);
      }
      const suggestions = newAddressJSON["suggestions"] || [];
      const newSuggestions = suggestions.map((x) => ({
        value: x,
        label: `${x.primary_line} ${x.city} ${x.state} ${x.zip_code}`
      }));
      return newSuggestions;
    },
    onBlur(event) {
      this.input = event.input;
    }
  }
};
const _withScopeId = (n) => (pushScopeId("data-v-6fb6a3ce"), n = n(), popScopeId(), n);
const _hoisted_1 = { class: "demo" };
const _hoisted_2 = { class: "row" };
const _hoisted_3 = { class: "column column-60" };
const _hoisted_4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1259 602",
  class: "lob-logo"
}, [
  /* @__PURE__ */ createElementVNode("path", {
    d: "M1063,141c-47.06,0-89,18.33-121,50.78V0H780V338.74C765,222.53,666.88,138,540,138c-137,0-242,101-242,232a235,235,0,0,0,7.7,60H164V0H0V585H307l14.54-112.68C359.94,550,441.74,602,540,602c127.75,0,225.08-83.62,240-200.41V585H930V540.27c31.8,37,77.27,56.73,133,56.73,103,0,196-109,196-228C1259,239,1175,141,1063,141ZM540,450c-45,0-81-36-81-80s36-80,81-80c46,0,81,35,81,80S585,450,540,450Zm475-1c-46,0-83-36-83-80a82.8,82.8,0,0,1,82.6-83h.4c47,0,85,37,85,83C1100,413,1062,449,1015,449Z",
    fill: "#0099d7"
  })
], -1));
const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "lob-header" }, "Deliverable addresses", -1));
const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("a", { href: "https://www.lob.com/address-verification?utm_source=autocomplete&utm_medium=vue" }, "Learn more", -1));
const _hoisted_7 = [
  _hoisted_4,
  _hoisted_5,
  _hoisted_6
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TypeAhead = resolveComponent("TypeAhead");
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createElementVNode("div", _hoisted_2, [
      createElementVNode("div", _hoisted_3, [
        createVNode(_component_TypeAhead, mergeProps({
          items: $data.addresses,
          placeholder: $props.placeholder,
          onOnInput: $options.onInput,
          onOnBlur: $options.onBlur,
          minInputLength: $props.minInputLength,
          itemProjection: $options.formatSuggestions,
          modelValue: $data.input,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.input = $event)
        }, _ctx.$attrs), {
          "list-header": withCtx(() => [
            createElementVNode("div", {
              class: "lob-label",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.handleClickHeader && $options.handleClickHeader(...args)),
              onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
              }, ["prevent"]))
            }, _hoisted_7, 32)
          ]),
          _: 1
        }, 16, ["items", "placeholder", "onOnInput", "onOnBlur", "minInputLength", "itemProjection", "modelValue"])
      ])
    ])
  ]);
}
var AddressAutocomplete = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-6fb6a3ce"]]);
const processApiResponse = (apiResponse) => apiResponse.json().then((data) => "error" in data ? Promise.reject(new Error(data.error.message)) : data);
const verify = (apiKey, address) => {
  if (!Object.keys(address || {}).length) {
    return Promise.reject(new Error("Empty address was passed to verify function"));
  }
  if (!apiKey.length) {
    return Promise.reject(new Error("Missing API key"));
  }
  return postVerifyAddress(apiKey, address).then(processApiResponse);
};
const verifyInternational = (apiKey, address, countryCode) => {
  if (!Object.keys(address || {}).length) {
    return Promise.reject(new Error("Empty address was passed to verify function"));
  }
  if (!apiKey.length) {
    return Promise.reject(new Error("Missing API key"));
  }
  if (typeof countryCode !== "string") {
    return Promise.reject(new Error("Expected countryCode to be of type string"));
  }
  if (/[A-Z]{2}/.test(countryCode) === false) {
    return Promise.reject(new Error("countryCode must be a 2 letter country short-name code (ISO 3166)"));
  }
  return postVerifyInternationalAddress(apiKey, address, countryCode).then(processApiResponse);
};
function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;
  Vue.component("AddressAutocomplete", AddressAutocomplete);
}
const plugin = { install };
let GlobalVue;
if (typeof window !== "undefined") {
  GlobalVue = window.Vue;
} else if (typeof global !== "undefined") {
  GlobalVue = global.Vue;
}
if (GlobalVue) {
  GlobalVue.use(plugin);
}
AddressAutocomplete.install = install;
export { AddressAutocomplete as default, verify, verifyInternational };
